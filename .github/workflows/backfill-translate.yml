// scripts/backfill-translate.js (conservador)
// Traduce hist√≥ricos en workspace/astro/public/articles.json
// SOLO escribe title_es/content_es cuando obtiene una TRADUCCI√ìN REAL distinta del original.
// No copia el t√≠tulo original al campo *_es. No toca date/published ni el orden.
// Uso:
//   DEEPL_API_KEY=xxx node scripts/backfill-translate.js
// Opcionales: DEEPL_ENDPOINT (https://api-free.deepl.com | https://api.deepl.com), BACKFILL_LIMIT (300), SLEEP_MS (1200)

import fs from "fs";
import path from "path";
import fetch from "node-fetch";
import { franc } from "franc";

const FILE = "workspace/astro/public/articles.json";
const BACKUP = "workspace/astro/public/articles.backup.json";
const USER_AGENT = process.env.USER_AGENT || "curioscience-bot/1.0";
const DEEPL_KEY = process.env.DEEPL_API_KEY || "";
const DEEPL_ENDPOINT = process.env.DEEPL_ENDPOINT || "https://api-free.deepl.com"; // Free por defecto
const BACKFILL_LIMIT = Number(process.env.BACKFILL_LIMIT || 300);
const SLEEP_MS = Number(process.env.SLEEP_MS || 1200);

if (!DEEPL_KEY) {
  console.error("‚ùå Falta DEEPL_API_KEY en el entorno.");
  process.exit(1);
}

// Mapa franc (ISO-639-3) ‚Üí DeepL (dos letras)
const LANG_MAP = { eng:'EN', spa:'ES', fra:'FR', deu:'DE', ita:'IT', por:'PT', nld:'NL', pol:'PL', rus:'RU', jpn:'JA', zho:'ZH', bul:'BG', ces:'CS', dan:'DA', ell:'EL', est:'ET', fin:'FI', hun:'HU', lit:'LT', lav:'LV', ron:'RO', slk:'SK', slv:'SL', swe:'SV', tur:'TR', ukr:'UK' };
const toDeepL = (code3) => LANG_MAP[code3];
const sleep = (ms) => new Promise(r => setTimeout(r, ms));

function ensureDirFor(p){ fs.mkdirSync(path.dirname(p), { recursive: true }); }
function loadJSON(p){ return fs.existsSync(p) ? JSON.parse(fs.readFileSync(p, "utf-8")) : []; }
function saveJSON(p, data){ ensureDirFor(p); fs.writeFileSync(p, JSON.stringify(data, null, 2)); }

function detectLang2(text){
  const sample = String(text || '').slice(0, 800);
  const code3 = franc(sample, { minLength: 10 }); // 'eng', 'spa', 'und'...
  return toDeepL(code3); // puede ser undefined
}

async function deeplTranslate(text, targetLang, sourceLang){
  if (!text) return text;
  const body = new URLSearchParams();
  body.set("text", String(text).slice(0, 4000));
  body.set("target_lang", String(targetLang || 'ES').toUpperCase());
  if (sourceLang) body.set("source_lang", String(sourceLang).toUpperCase());
  try{
    const res = await fetch(`${DEEPL_ENDPOINT}/v2/translate`, {
      method: "POST",
      headers: {
        Authorization: `DeepL-Auth-Key ${DEEPL_KEY}`,
        "Content-Type": "application/x-www-form-urlencoded",
        "user-agent": USER_AGENT,
      },
      body,
    });
    if (!res.ok) {
      console.warn(`[DeepL] ${DEEPL_ENDPOINT} HTTP ${res.status}`);
      return text; // devolvemos original para no escribir *_es si no hay traducci√≥n
    }
    const data = await res.json();
    return data?.translations?.[0]?.text || text;
  }catch(e){
    console.warn("[DeepL]", e.message);
    return text;
  }
}

function needsTranslation(item){
  const titleMissing   = !item.title_es || item.title_es.trim() === '';
  const contentMissing = !item.content_es || item.content_es.trim() === '';
  const titleSameAsSrc = (item.title_es || '').trim() === (item.title || '').trim();
  const title = item.title || '';
  const summarySeed = item.content_es || item.summary || item.description || '';
  const lang = detectLang2(`${title} ${summarySeed}`) || 'EN';
  // Pendiente si falta algo, si *_es == original en fuentes inglesas o si detectamos no-ES
  return titleMissing || contentMissing || titleSameAsSrc || (lang !== 'ES');
}

async function translateItem(item){
  const title = item.title || '';
  const summarySeed = item.content_es || item.summary || item.description || '';
  const lang = (detectLang2(`${title} ${summarySeed}`) || 'EN');

  // Si ya est√° en espa√±ol: solo completa los campos que falten (sin copiar a lo loco otros)
  if (lang === 'ES') {
    const next = { ...item };
    if (!next.title_es || next.title_es.trim() === '') next.title_es = title;
    if (!next.content_es || next.content_es.trim() === '') next.content_es = (summarySeed || title);
    return next;
  }

  // Intento de traducci√≥n (con pausa entre llamadas para evitar 429)
  const title_tr = await deeplTranslate(title, 'ES', lang);
  await sleep(SLEEP_MS);
  const content_src = summarySeed || title; // si no hay resumen, traducimos el t√≠tulo
  const content_tr = await deeplTranslate(content_src, 'ES', lang);

  const next = { ...item };
  // Solo escribimos si la traducci√≥n NO es igual al original (evita dejar ingl√©s en *_es)
  if ((!next.title_es || next.title_es.trim() === '') && title_tr && title_tr.trim() !== title.trim()) {
    next.title_es = title_tr;
  }
  if ((!next.content_es || next.content_es.trim() === '') && content_tr && content_tr.trim() !== content_src.trim()) {
    next.content_es = content_tr;
  }
  return next;
}

async function main(){
  const all = loadJSON(FILE);
  if (!Array.isArray(all) || all.length === 0){
    console.log("Nada que traducir (archivo vac√≠o o no es array)");
    return;
  }

  ensureDirFor(BACKUP);
  fs.copyFileSync(FILE, BACKUP);
  console.log(`üóÇ  Backup creado en ${BACKUP}`);

  const toProcessIdx = [];
  for (let i=0; i<all.length; i++) {
    if (needsTranslation(all[i])) toProcessIdx.push(i);
  }
  console.log(`Encontrados ${toProcessIdx.length} art√≠culos a traducir (faltan ES / est√°n en ingl√©s / id√©nticos).`);

  if (toProcessIdx.length === 0){
    console.log("Todo ya est√° traducido. ‚úîÔ∏è");
    return;
  }

  const limit = Math.min(BACKFILL_LIMIT, toProcessIdx.length);
  console.log(`Traduciendo ${limit} art√≠culos ahora (BACKFILL_LIMIT=${BACKFILL_LIMIT}).`);

  for (let k=0; k<limit; k++){
    const idx = toProcessIdx[k];
    const original = all[idx];
    try{
      const translated = await translateItem(original);
      // Conserva fecha/orden; SOLO actualiza campos ES cuando hay traducci√≥n real
      all[idx] = { ...original, ...(['title_es','content_es'].reduce((acc, f)=>{
        if (translated[f] && translated[f].trim() !== '') acc[f] = translated[f];
        return acc;
      }, {})) };
      if ((k+1) % 25 === 0) console.log(`...${k+1}/${limit} traducidos`);
    }catch(e){
      console.warn(`Error traduciendo idx=${idx}:`, e.message);
    }
    await sleep(SLEEP_MS);
  }

  saveJSON(FILE, all);
  console.log(`‚úîÔ∏è Guardado ${FILE} con traducciones a√±adidas. No se tocaron date/published.`);
}

main().catch(e=>{ console.error("Fallo en backfill-translate:", e); process.exit(1); });
